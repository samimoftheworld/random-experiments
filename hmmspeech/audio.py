import pyaudio, sys, threading, struct

# class used to pass audio events between threads
class Record_Event() :
	def __init__(self,stream,rate,chunk) :
		self.stream = stream
		self.rate = rate
		self.chunk = chunk

	# return a tuple of the member variables
	def unpack(self) :
		return (self.stream,self.rate,self.chunk)


# class to handle microphone stream
class Microphone() :

	def __init__(self,parent,rate,chunk,handler) :

		# pyaudio uses ALSA, which may occasionally print a long 
		# list of error messages to the terminal
		# capturing stderr in python doesn't work, since the errors 
		# aren't generated by python. However, using ctypes we can capture
		# the error and briefly reset the error handler

		# From alsa-lib Git 3fd4ab9be0db7c7430ebd258f2717a976381715d
		# $ grep -rn snd_lib_error_handler_t
		# include/error.h:59:typedef void (*snd_lib_error_handler_t)(const char *file, int line, const char *function, int err, const char *fmt, ...) /* __attribute__ ((format (printf, 5, 6))) */;
		# Define our custom error handler type
		# ERROR_HANDLER_FUNC = CFUNCTYPE(None, c_char_p, c_int, c_char_p, c_int, c_char_p)

		# def py_error_handler(filename, line, function, err, fmt):
		# 	pass

		# c_error_handler = ERROR_HANDLER_FUNC(py_error_handler)
		# asound = cdll.LoadLibrary('libasound.so')
		# # Set error handler to our custom function
		# asound.snd_lib_error_set_handler(c_error_handler)

		# now initialize pyaudio and reset error handler to the default
		self.p = pyaudio.PyAudio()
		# asound.snd_lib_error_set_handler(None)

		self.chunk = chunk # number of samples per callback
		self.format = pyaudio.paInt16
		self.channels = 1
		self.rate = rate
		self.active = False
		self.parent = parent
		self.handler = handler

	# stream callback
	def __callback(self,in_data, frame_count, time_info, status) :

		# 'extend' is the recording chunk generated in each loop
		# 'extend' is added to the streamData after each loop
		# and sent as a 'Record_Event' to the analytics window
		extend = [] 
		for i in range(0,len(in_data)) :
			if i%2 != 0 :
				continue
			# convert 2-digit binary into signed int
			extend.append(struct.unpack("<h", in_data[i:i+2])[0])
		self.streamData.extend(extend)

		if self.active :
			return (in_data, pyaudio.paContinue)
		return (in_data, pyaudio.paComplete)

	# initiate a microphone stream
	def startStream(self) :
		self.streamData = []
		self.active = True
		self.stream = self.p.open(
			format=self.format,
			channels=self.channels,
			rate=self.rate,
			input=True,
			frames_per_buffer=self.chunk,
			stream_callback=self.__callback )
		self.stream.start_stream()

	# halt the stream
	def pause(self) :
		if self.stream.is_active() :
			self.active = False

		# send the stream to the analytics module
		# for processing
		# generate a record event
		event = Record_Event(
			self.streamData,
			self.rate,
			self.chunk)
		if self.handler :
			self.handler.handle_mic_event(event)
